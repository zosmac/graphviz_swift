<?xml version="1.0"?>
<?xml-stylesheet href="attributes.xslt" type="text/xsl"?>
<xsd:schema
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:gv="urn:graphviz">

    <!-- OVERVIEW -->

    <xsd:annotation id="Introduction">
        <xsd:documentation>
        <![CDATA[
            <p>
                Note that attribute names are case-sensitive. This is usually true for attribute values as well, unless noted.
            </p>
            <p>
                All Graphviz attributes are specified by name-value pairs. Thus, to set the <a href="#color">color</a> of a node <code>abc</code>, one would use
            </p>
            <p>
                <code>abc [color = red]</code>
            </p>
            <p>
                Similarly, to set the arrowhead style of an edge <code>abc -> def</code>, one would use
            </p>
            <p>
                <code>abc -> def [arrowhead = diamond]</code>
            </p>
            <p>
                Further details concerning the setting of attributes can be found in the description of the <a href="https://www.graphviz.org/doc/info/lang.html">DOT language.</a>
            </p>
            <p>
                From the Help menu, select Graphviz Help to open Graphviz documentation in your browser.
            </p>
            <p>
                From the Help menu, select GraphvizSwift Help to view the README.
            </p>
        ]]>
        </xsd:documentation>
    </xsd:annotation>

    <xsd:annotation id="points">
        <xsd:documentation>
        <![CDATA[
            <p>
                At present, most device-independent units are either inches or <a href="http://en.wikipedia.org/wiki/Point_(typography)">points</a>, which we take as 72 points per inch.
            </p>
        ]]>
        </xsd:documentation>
    </xsd:annotation>

    <xsd:annotation id="undirected">
        <xsd:documentation>
        <![CDATA[
            <p>
                <b>Note:</b> Some attributes, such as <a href="#dir">dir</a> or <a href="#arrowtail">arrowtail</a>, are ambiguous when used in <a href="https://www.graphviz.org/doc/info/lang.html">DOT</a> with an undirected graph since the head and tail of an edge are meaningless. As a convention, the first time an undirected edge appears, the <a href="https://www.graphviz.org/doc/info/lang.html">DOT</a> parser will assign the left node as the tail node and the right node as the head. For example, the edge <code>A -- B</code> will have tail <code>A</code> and head <code>B</code>. It is the user's responsibility to handle such edges consistently. If the edge appears later with format
            </p>
            <p>
                <code>B -- A [taillabel = "tail"]</code>
            </p>
            <p>
                then the drawing will attach the tail label to node <code>A</code>. To avoid possible confusion when such attributes are required, the user is encouraged to use a directed graph. If it is important to make the graph appear undirected, this can be done using the <a href="#dir">dir</a>, <a href="#arrowtail">arrowtail</a> or <a href="#arrowhead">arrowhead</a> attributes.
            </p>
        ]]>
        </xsd:documentation>
    </xsd:annotation>

    <!-- ATTRIBUTE TYPES -->

    <!-- xsd:simpleType template

    <xsd:simpleType name="...">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
-
        <xsd:list itemType="..." />
- OR -
        <xsd:restriction base="string">
            <xsd:enumeration value="..." />
        </xsd:restriction>
-
    </xsd:simpleType>

    -->

    <xsd:simpleType name="arrowType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Edge arrowhead shape
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="normal" />
            <xsd:enumeration value="inv" />
            <xsd:enumeration value="dot" />
            <xsd:enumeration value="invdot" />
            <xsd:enumeration value="odot" />
            <xsd:enumeration value="invodot" />
            <xsd:enumeration value="none" />
            <xsd:enumeration value="tee" />
            <xsd:enumeration value="empty" />
            <xsd:enumeration value="invempty" />
            <xsd:enumeration value="diamond" />
            <xsd:enumeration value="odiamond" />
            <xsd:enumeration value="ediamond" />
            <xsd:enumeration value="crow" />
            <xsd:enumeration value="box" />
            <xsd:enumeration value="obox" />
            <xsd:enumeration value="open" />
            <xsd:enumeration value="halfopen" />
            <xsd:enumeration value="vee" />
            <xsd:enumeration value="" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Boolean
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:boolean">
            <xsd:enumeration value="true" />
            <xsd:enumeration value="false" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="clusterMode">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="local" />
            <xsd:enumeration value="global" />
            <xsd:enumeration value="none" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="color">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Colors can be specified using one of five formats
                </p>
                <p>
                    <table><tbody>
                        <tr>
                            <td><code>#%2x%2x%2x</code></td>
                            <td>Red-Green-Blue (RGB)</td>
                        </tr>
                        <tr>
                            <td><code>#%1x%1x%1x</code></td>
                            <td>Shorthand Red-Green-Blue (RGB)</td>
                        </tr>
                        <tr>
                            <td><code>#%2x%2x%2x%2x</code></td>
                            <td>Red-Green-Blue-Alpha (RGBA)</td>
                        </tr>
                        <tr>
                            <td><code>H[,&#160;]+S[,&#160;]+V</code></td>
                            <td>Hue-Saturation-Value (HSV) 0.0 &lt;= H,S,V &lt;= 1.0</td>
                        </tr>
                        <tr>
                            <td><code>H[,&#160;]+S[,&#160;]+V[,&#160;]A</code></td>
                            <td>Hue-Saturation-Value-Alpha (HSVA) 0.0 &lt;= H,S,V,A &lt;= 1.0</td>
                        </tr>
                        <tr>
                            <td>string</td>
                            <td><a href="https://www.graphviz.org/doc/info/colors.html">color name</a></td>
                        </tr>
                    </tbody></table>
                </p>
                <p>
                    The specification for the RGB and RGBA formats are the format strings used by <code>sscanf</code> to scan the color value. Thus, these values have the form "#RGB" or "#RGBA", where R, G, B, and A each consist of 2 hexadecimal digits, and can be separated by whitespace. As of Graphviz 9.0.0, RGB components can also be given as 1 hexadecimal digit. These are each doubled to form 2-digit components, similar to shorthand HTML colors. HSV colors have the form of 3 or (as of Graphviz 8.0.1) 4 numbers between 0 and 1, separated by whitespace or commas.
                </p>
                <p>
                    String-valued color specifications are case-insensitive and interpreted in the context of the current color scheme, as specified by the <a href="https://www.graphviz.org/docs/attrs/colorscheme/">colorscheme</a> attribute. If this is undefined, the X11 naming scheme will be used. An initial "/" character can be used to override the use of the colorscheme attribute. In particular, a single initial "/" will cause the string to be evaluated using the default X11 naming. If the color value has the form "/ssss/yyyy", the name yyyy is interpreted using the schema ssss. If the color scheme name is empty, i.e., the color has the form "//yyyy", the colorscheme attribute is used. Thus, the forms "yyyy" and "//yyyy" are equivalent.
                </p>
                <p>
                    At present, Graphviz recognizes the default color scheme <code>X11</code>, and the <a href="https://www.graphviz.org/doc/info/colors.html#brewer">Brewer color schemes</a> (cf. <a href="https://en.wikipedia.org/wiki/ColorBrewer">ColorBrewer</a>). Please note that Brewer color schemes are covered by this <a href="https://www.graphviz.org/doc/info/colors.html#brewer_license">license</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string" />
    </xsd:simpleType>

    <xsd:simpleType name="colorList">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    A colon-separated list of (optionally weighted) color values, forming a linear gradient.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:list itemType="color" />
    </xsd:simpleType>

    <xsd:simpleType name="dirType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    For undirected edges <code>T -- H;</code>, one of the nodes, usually the righthand one, is treated as the head for the purpose of interpreting <code>forward</code> and <code>back</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="forward" />
            <xsd:enumeration value="back" />
            <xsd:enumeration value="both" />
            <xsd:enumeration value="none" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Decimal number
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:double" />
    </xsd:simpleType>

    <xsd:simpleType name="doubleList">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    A colon-separated list of <a href="#double">doubles</a>: <code>%f(:%f)*</code> where each %f is a double.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:list itemType="double" />
    </xsd:simpleType>

    <xsd:simpleType name="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    A <a href="#string">string</a> allowing backslashed escape sequences which are replaced according to the context. For node attributes, the substring <code>\N</code> is replaced by the name of the node, and the substring <code>\G</code> by the name of the graph. For graph or cluster attributes, the substring <code>\G</code> is replaced by the name of the graph or cluster. For edge attributes, the substring <code>\E</code> is replaced by the name of the edge, the substring <code>\G</code> is replaced by the name of the graph or cluster, and the substrings <code>\T</code> and <code>\H</code> by the names of  the tail and head nodes, respectively. The name of an edge is the string formed from the name of the tail node, the appropriate edge operator (<code>--</code> or <code>-></code>) and the name of the head node.
                </p>
                <p>
                    In addition, if the associated attribute is <a href="#label">label</a>, <a href="#headlabel">headlabel</a> or <a href="#taillabel">taillabel</a>, the escape sequences <code>\n</code>, <code>\l</code> and <code>\r</code> divide the label into lines, centered, left-justified, and right-justified, respectively.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string" />
    </xsd:simpleType>

    <xsd:simpleType name="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Integer number
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:integer" />
    </xsd:simpleType>

    <xsd:simpleType name="layerList">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    List of strings separated by characters from the <a href="#layersep">layersep</a> attribute (by default, colons, tabs or spaces), defining <a href="#layer">layer</a> names and implicitly numbered 1,2,...
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:list itemType="layer" />
    </xsd:simpleType>

    <xsd:simpleType name="layerRange">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    A list of layers defined by the <a href="#layers">layers</a> attribute
                </p>
                <p>
                    It consists of a list of layer intervals separated by any collection of characters from the <code>layerlistsep</code> attribute. Each layer interval is specified as either a layerId or a layerId<b>S</b>layerId, where layerId = "all", an integer, or a layer name. (An integer i corresponds to layer i, layers being numbered from 1.)
                </p>
                <p>
                    The string <b>S</b> consists of 1 or more separator characters specified by the <a href="#layersep">layersep</a> attribute.
                </p>
                <p>
                    Thus, assuming the default values for <a href="#layersep">layersep</a> and <a href="#layerlistsep">layerlistsep</a>, if <a href="#layers">layers</a><code>="a:b:c:d:e:f:g:h"</code>, the layerRange string <a href="#layers">layers</a><code>="a:b,d,f:all"</code> would denote the layers a b d f g h.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:list itemType="layers" />
    </xsd:simpleType>

    <xsd:simpleType name="layoutEngine">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                Layout engine
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <!-- <xsd:enumeration value="..." /> -->
        </xsd:restriction>
-
    </xsd:simpleType>

    <xsd:simpleType name="lblString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Label string
                </p>
                <p>
                    An <a href="#escString">escString</a> or an HTML label.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string" />
    </xsd:simpleType>

    <xsd:simpleType name="modeType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Mode type for <code>neato</code>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="major" />
            <xsd:enumeration value="KK" />
            <xsd:enumeration value="sgd" />
            <xsd:enumeration value="heir" />
            <xsd:enumeration value="ipsep" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="outputMode">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    These specify the order in which nodes and edges are drawn in output.
                </p>
                <p>
                    <table><tbody>
                        <tr>
                            <td>
                                <code>breadthfirst</code>
                            </td>
                            <td>
                                Avoid edge-node overlap.
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>nodesfirst</code>
                            </td>
                            <td>
                                Draw nodes before edges.
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>edgesfirst</code>
                            </td>
                            <td>
                                Draw edges before nodes.
                            </td>
                        </tr>
                    </tbody></table>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="breadthfirst" />
            <xsd:enumeration value="nodesfirst" />
            <xsd:enumeration value="edgesfirst" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="overlapTechnique">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Node overlap removal technique
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="true" />
            <xsd:enumeration value="scale" />
            <xsd:enumeration value="false" />
            <xsd:enumeration value="prism" />
            <xsd:enumeration value="prism0" />
            <xsd:enumeration value="9:prism" />
            <xsd:enumeration value="voronoi" />
            <xsd:enumeration value="scalexy" />
            <xsd:enumeration value="compress" />
            <xsd:enumeration value="vspc" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="packMode">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    These specify the granularity of packing connected components when the <a href="#pack">pack</a> attribute is true. A value of <code>node</code> causes packing at the node and edge label, with no overlapping of these objects. This produces a layout with the least area, but it also allows interleaving, where a node of one component may lie between two nodes in another component. A value of <code>graph</code> does a packing using the bounding box of the component. Thus, there will be a rectangular region around a component free of elements of any other component. A value of <code>clust</code> guarantees that top-level clusters are kept intact. What effect a value has also depends on the layout algorithm. For example, neato does not support clusters, so a value of <code>clust</code> will have the same effect as the default <code>node</code> value.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="node" />
            <xsd:enumeration value="clust" />
            <xsd:enumeration value="graph" />
            <xsd:enumeration value="array_i" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="pagedir">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Page Direction
                </p>
                <p>
                    These specify the 8 row or column major orders for traversing a rectangular array, the first character corresponding to the major order and the second to the minor order. Thus, for "BL", the major order is from bottom to top, and the minor order is from left to right. This means the bottom row is traversed first, from left to right, then the next row up, from left to right, and so on, until the topmost row is traversed.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="BL" />
            <xsd:enumeration value="BR" />
            <xsd:enumeration value="TL" />
            <xsd:enumeration value="TR" />
            <xsd:enumeration value="RB" />
            <xsd:enumeration value="RT" />
            <xsd:enumeration value="LB" />
            <xsd:enumeration value="LT" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="point">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    2-dimensional (or 3-dimensional) geometrical point in space
                </p>
                <p>
                    <code>%f,%f('!')?</code> representing the point (x,y). The optional '!' indicates the node position should not change (input-only).
                </p>
                <p>
                    If <a href="#dim">dim</a><code>=3</code>, point may also have the format <code>%f,%f,%f('!')?</code> to represent the point (x,y,z).
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string" />
    </xsd:simpleType>

    <xsd:simpleType name="pointList">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    A list of <a href="#point">points</a>, separated by spaces.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:list itemType="point" />
    </xsd:simpleType>

    <xsd:simpleType name="portPos">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Port Position: where on nodes that edges should be aimed
                </p>
                <p>
                    Modifies edge placement to aim for the corresponding compass point on nodes. The default compass point <code>center</code> specifies the center of the node.
                </p>
                <p>
                    <table><tbody>
                        <tr>
                            <td><code>center</code></td>
                            <td>Center</td>
                        </tr>
                        <tr>
                            <td><code>n</code></td>
                            <td>North</td>
                        </tr>
                        <tr>
                            <td><code>ne</code></td>
                            <td>Northeast</td>
                        </tr>
                        <tr>
                            <td><code>e</code></td>
                            <td>East</td>
                        </tr>
                        <tr>
                            <td><code>se</code></td>
                            <td>Southeast</td>
                        </tr>
                        <tr>
                            <td><code>s</code></td>
                            <td>South</td>
                        </tr>
                        <tr>
                            <td><code>sw</code></td>
                            <td>Southwest</td>
                        </tr>
                        <tr>
                            <td><code>w</code></td>
                            <td>West</td>
                        </tr>
                        <tr>
                            <td><code>nw</code></td>
                            <td>Northwest</td>
                        </tr>
                    </tbody></table>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="center" />
            <xsd:enumeration value="n" />
            <xsd:enumeration value="ne" />
            <xsd:enumeration value="e" />
            <xsd:enumeration value="se" />
            <xsd:enumeration value="s" />
            <xsd:enumeration value="sw" />
            <xsd:enumeration value="w" />
            <xsd:enumeration value="nw" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="quadType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Quadtree scheme
                </p>
                <p>
                    Using <code>fast</code> gives about a 2-4 times overall speedup compared with <code>normal</code>, though layout quality can suffer a little.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="normal" />
            <xsd:enumeration value="fast" />
            <xsd:enumeration value="none" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="rankdir">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Corresponding to directed graphs drawn from from top to bottom, from left to right, from bottom to top, and from right to left, respectively.
                </p>
                <p>
                    <table><tbody>
                        <tr>
                            <td>
                                <code>TB</code>
                            </td>
                            <td>
                                top to bottom
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>LR</code>
                            </td>
                            <td>
                                left to right
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>BT</code>
                            </td>
                            <td>
                                bottom to top
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>RL</code>
                            </td>
                            <td>
                                right to left
                            </td>
                        </tr>
                    </tbody></table>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="TB" />
            <xsd:enumeration value="LR" />
            <xsd:enumeration value="BT" />
            <xsd:enumeration value="RL" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="rankType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Rank constraints on the nodes in a subgraph
                </p>
                <p>
                <table><tbody>
                    <tr>
                        <td><code>#%2x%2x%2x</code></td>
                        <td>Red-Green-Blue (RGB)</td>
                    </tr>
                    <tr>
                        <td><code>#%1x%1x%1x</code></td>
                        <td>Shorthand Red-Green-Blue (RGB)</td>
                    </tr>
                    <tr>
                        <td><code>#%2x%2x%2x%2x</code></td>
                        <td>Red-Green-Blue-Alpha (RGBA)</td>
                    </tr>
                    <tr>
                        <td><code>H[,&#160;]+S[,&#160;]+V</code></td>
                        <td>Hue-Saturation-Value (HSV) 0.0 &lt;= H,S,V &lt;= 1.0</td>
                    </tr>
                    <tr>
                        <td><code>H[,&#160;]+S[,&#160;]+V[,&#160;]A</code></td>
                        <td>Hue-Saturation-Value-Alpha (HSVA) 0.0 &lt;= H,S,V,A &lt;= 1.0</td>
                    </tr>
                    <tr>
                        <td>string</td>
                        <td><a href="https://www.graphviz.org/doc/info/colors.html">color name</a></td>
                    </tr>
                </tbody></table>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="same" />
            <xsd:enumeration value="min" />
            <xsd:enumeration value="source" />
            <xsd:enumeration value="max" />
            <xsd:enumeration value="sink" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="ratioType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Aspect ratio for the drawing
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="fill" />
            <xsd:enumeration value="compress" />
            <xsd:enumeration value="expand" />
            <xsd:enumeration value="auto" />
            <xsd:enumeration value="1.33" />
            <xsd:enumeration value="0.75" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="rect">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    A geometric rectangle in space, defined by two <a href="#point">points</a> <code>%f,%f,%f,%f</code>
                </p>
                <p>
                    The rectangle <code>llx,lly,urx,ury</code> gives the coordinates, in points, of the lower-left corner (<code>llx,lly</code>) and the upper-right corner (<code>urx,ury</code>).
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:list itemType="point" />
    </xsd:simpleType>

    <xsd:simpleType name="shapeType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    The polygon-based shape of a node.
                </p>
                <p>
                    The record-based shape has largely been superseded and greatly generalized by HTML-like labels. That is, instead of using shape=record, consider using shape=none and an HTML-like label.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="box" />
            <xsd:enumeration value="polygon" />
            <xsd:enumeration value="ellipse" />
            <xsd:enumeration value="circle" />
            <xsd:enumeration value="point" />
            <xsd:enumeration value="egg" />
            <xsd:enumeration value="triangle" />
            <xsd:enumeration value="plaintext" />
            <xsd:enumeration value="plain" />
            <xsd:enumeration value="diamond" />
            <xsd:enumeration value="trapezium" />
            <xsd:enumeration value="parallelogram" />
            <xsd:enumeration value="house" />
            <xsd:enumeration value="pentagon" />
            <xsd:enumeration value="hexagon" />
            <xsd:enumeration value="septagon" />
            <xsd:enumeration value="octagon" />
            <xsd:enumeration value="doublecircle" />
            <xsd:enumeration value="doubleoctagon" />
            <xsd:enumeration value="tripleoctagon" />
            <xsd:enumeration value="invtriangle" />
            <xsd:enumeration value="invtrapezium" />
            <xsd:enumeration value="invhouse" />
            <xsd:enumeration value="Mdiamond" />
            <xsd:enumeration value="Msquare" />
            <xsd:enumeration value="Mcircle" />
            <xsd:enumeration value="rect" />
            <xsd:enumeration value="rectangle" />
            <xsd:enumeration value="square" />
            <xsd:enumeration value="star" />
            <xsd:enumeration value="none" />
            <xsd:enumeration value="note" />
            <xsd:enumeration value="tab" />
            <xsd:enumeration value="folder" />
            <xsd:enumeration value="box3d" />
            <xsd:enumeration value="component" />
            <xsd:enumeration value="promoter" />
            <xsd:enumeration value="cds" />
            <xsd:enumeration value="terminator" />
            <xsd:enumeration value="utr" />
            <xsd:enumeration value="primersite" />
            <xsd:enumeration value="restrictionsite" />
            <xsd:enumeration value="fivepoverhang" />
            <xsd:enumeration value="threepoverhang" />
            <xsd:enumeration value="noverhang" />
            <xsd:enumeration value="assembly" />
            <xsd:enumeration value="signature" />
            <xsd:enumeration value="insulator" />
            <xsd:enumeration value="ribosite" />
            <xsd:enumeration value="rnastab" />
            <xsd:enumeration value="proteasesite" />
            <xsd:enumeration value="proteinstab" />
            <xsd:enumeration value="rpromoter" />
            <xsd:enumeration value="rarrow" />
            <xsd:enumeration value="larrow" />
            <xsd:enumeration value="lpromoter" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="smoothType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Values are
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="none" />
            <xsd:enumeration value="avg_dist" />
            <xsd:enumeration value="graph_dist" />
            <xsd:enumeration value="power_dist" />
            <xsd:enumeration value="rng" />
            <xsd:enumeration value="spring" />
            <xsd:enumeration value="triangle" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="splineType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    <code>spline ( ';' spline )*</code>
                </p>
                <p>
                    <ul>
                        <li>
                            where <code>spline = (endp)? (startp)? point (triple)+</code>
                        </li>
                        <li>
                            and <code>triple = point point point</code>
                        </li>
                        <li>
                            and <code>endp = "e,%f%f"</code>
                        </li>
                        <li>
                            and <code>startp = "s,%f%f"</code>
                        </li>
                    </ul>
                </p>
                <p>
                    If a spline has points p₁ p₂ p₃ ... pₙ, (n = 1 (mod 3)), the points correspond to the control points of a cubic B-spline from p₁ to pₙ. If startp is given, it touches one node of the edge, and the arrowhead goes from p₁ to startp. If startp is not given, p₁ touches a node. Similarly for pₙ and endp.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string" />
    </xsd:simpleType>

    <xsd:simpleType name="startType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    How to initially layout nodes
                </p>
                <p>
                    Syntax <code>(style)?(seed)?</code>. If <code>style</code> is present, it must be one of the strings
                    <table><tbody>
                        <tr>
                            <td><code>regular</code></td>
                            <td>place nodes regularly about a circle</td>
                        </tr>
                        <tr>
                            <td><code>self</code></td>
                            <td>run an abbreviated version of neato to obtain the initial layout</td>
                        </tr>
                        <tr>
                            <td><code>random</code></td>
                            <td>place nodes randomly in a unit square</td>
                        </tr>
                    </tbody></table>
                </p>
                <p>
                    If <code>seed</code> is present, it specifies a seed for the random number generator. If seed is a positive number, this is used as the seed. If it is anything else, the current time, and possibly the process id, is used to pick a seed, thereby making the choice more random. In this case, the seed value is stored in the graph.
                </p>
                <p>
                    If the value is just <code>random</code>, a time-based seed is chosen.
                </p>
                <p>
                    Note that input positions, specified by a node's <a href="#pos">pos</a> attribute, are only used when the style is <code>random</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string">
            <xsd:enumeration value="regular" />
            <xsd:enumeration value="self" />
            <xsd:enumeration value="random" />
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Text; a sequence of characters.
                </p>
                <p>
                    See also <a href="#escString">escString</a>, text with escape-sequences.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="string" />
    </xsd:simpleType>

    <!--
    style
    viewPort
    -->

    <!--  ATTRIBUTES -->

    <!-- xsd:attribute template

    <xsd:attribute name="..." type="...">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    -->

    <!--
    _background (xdot)
    -->

    <xsd:attribute name="area" type="double" default="1.0" gv:layouts="patchwork">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Indicates the preferred area for a node or empty cluster
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="arrowhead" type="arrowType" default="normal">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Style of arrowhead on the head node of an edge
                </p>
                <p>
                    This will only appear if the <a href="#dir">dir</a> attribute is <code>forward</code> or <code>both</code>.
                </p>
                <p>
                    See the limitation regarding <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="arrowsize" type="double" default="1.0">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Multiplicative scale factor for arrowheads
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="arrowtail" type="arrowType" default="normal">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Style of arrowhead on the tail node of an edge
                </p>
                <p>
                    This will only appear if the <a href="#dir">dir</a> attribute is <code>back</code> or <code>both</code>.
                </p>
                <p>
                    See the limitation regarding <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="bb" type="rect">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Bounding box of drawing in integer points
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="beautify" type="bool" default="false" gv:layouts="sfdp">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Whether to draw leaf nodes uniformly in a circle around the root node in sfdp.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="bgcolor" type="color">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    When attached to the root graph, this color is used as the background for entire canvas. When a cluster attribute, it is used as the initial background for the cluster. If a cluster has a filled <a href="#style">style</a>, the cluster's <a href="#fillcolor">fillcolor</a> will overlay the background color.
                </p>
                <p>
                    If no background color is specified for the root graph, no graphics operation are performed on the background. This works fine for PostScript but for bitmap output, all bits are initialized to something. This means that when the bitmap output is included in some other document, all of the bits within the bitmap's bounding box will be set, overwriting whatever color or graphics where already on the page. If this effect is not desired, and you only want to set bits explicitly assigned in drawing the graph, set <a href="#bgcolor">bgcolor</a><code>=transparent</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="center" type="bool" default="false">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If true, the drawing is centered in the output canvas.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="charset" type="string" default="UTF-8">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies the character encoding used when interpreting string input as a text label. The default value is <code>UTF-8</code>. The other legal value is <code>iso-8859-1</code> or, equivalently, <code>Latin1</code>. The <a href="#charset">charset</a> attribute is case-insensitive. Note that if the character encoding used in the input does not match the <a href="#charset">charset</a> value, the resulting output may be very strange.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="class" type="string" gv:formats="svg">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Classnames to attach to the node, edge, graph, or cluster's SVG element.
                </p>
                <p>
                    Combine with <a href="#stylesheet">stylesheet</a> for styling SVG output using CSS classnames.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    cluster
    -->

    <xsd:attribute name="clusterrank" type="clusterMode" default="local" gv:layouts="dot">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Mode used for handling clusters. If <a href="#clusterrank">clusterrank</a><code>=local</code>, a subgraph whose name begins with <code>cluster</code> is given special treatment. The subgraph is laid out separately, and then integrated as a unit into its parent graph, with a bounding rectangle drawn about it. If the cluster has a <a href="#label">label</a> parameter, this label is displayed within the rectangle. Note also that there can be clusters within clusters. The modes <a href="#clusterrank">clusterrank</a><code>=global</code> and <a href="#clusterrank">clusterrank</a><code>=none</code> appear to be identical, both turning off the special cluster processing.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="color" type="colorList" default="black">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Basic drawing color for graphics, not text. For the latter, use the <a href="#fontcolor">fontcolor</a> attribute.
                </p>
                <p>
                    For edges, the value can either be a single <a href="#color">color</a> or a <a href="#colorList">colorList</a>. In the latter case, the edge is drawn using parallel splines or lines, one for each color in the list, in the order given. The head arrow, if any, is drawn using the first color in the list, and the tail arrow, if any, the second color. This supports the common case of drawing opposing edges, but using parallel splines instead of separately routed multiedges.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="colorscheme" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This attribute specifies a color scheme namespace. If defined, it specifies the context for interpreting color names. In particular, if a <a href="#color">color</a> value has form <code>xxx</code> or <code>//xxx</code>, then the color <code>xxx</code> will be evaluated according to the current color scheme. If no color scheme is set, the standard X11 naming is used. For example, if <a href="#colorscheme">colorscheme</a><code>=bugn9</code>, then <a href="#color">color</a><code>=7</code> is interpreted as <code>/bugn9/7</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="comment" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Comments are inserted into output. Device-dependent.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="compound" type="bool" default="false" gv:layouts="dot">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <code>true</code>, allow edges between clusters. (See <a href="#lhead">lhead</a> and <a href="#ltail">ltail</a> below.)
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="concentrate" type="bool" default="false" gv:layouts="dot">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <code>true</code>, use edge concentrators.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="constraint" type="bool" default="true" gv:layouts="dot">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <code>false</code>, the edge is not used in ranking the nodes.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="Damping" type="double" default="0.99" gv:layouts="neato">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Factor damping force motions. On each iteration, a nodes movement is limited to this factor of its potential motion. By being less than 1.0, the system tends to "cool", thereby preventing cycling.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="decorate" type="bool" default="false">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <code>true</code>, attach edge label to edge by a 2-segment polyline, underlining the label, then going to the closest point of spline.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="defaultdist" type="double" gv:layouts="neato">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This specifies the distance between nodes in separate connected components. If set too small, connected components may overlap. Only applicable if <a href="#pack">pack</a><code>=false</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="dim" type="int" default="2" gv:layouts="fdp neato sfdp">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Set the number of dimensions used for the layout. The maximum value allowed is 10.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    dimen
    -->

    <xsd:attribute name="dir" type="dirType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Set edge type for drawing arrowheads. This indicates which ends of the edge should be decorated with an arrowhead. The actual style of the arrowhead can be specified using the <a href="#arrowhead">arrowhead</a> and <a href="#arrowtail">arrowtail</a> attributes. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="diredgeconstraints" type="string" default="false" gv:layouts="neato">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Only valid when <a href="#mode">mode</a><code>=ipsep</code>. If <code>true</code>, constraints are generated for each edge in the largest (heuristic) directed acyclic subgraph such that the edge must point downwards. If <code>hier</code>, generates level constraints similar to those used with <a href="#mode">mode</a><code>=hier</code>. The main difference is that, in the latter case, only these constraints are involved, so a faster solver can be used.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="distortion" type="double" default="0.0">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Distortion factor for <a href="#shape">shape</a><code>=polygon</code>. Positive values cause top part to be larger than bottom; negative values do the opposite.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="dpi" type="double" default="96.0">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This specifies the expected number of pixels per inch on a display device. For bitmap output, this guarantees that text rendering will be done more accurately, both in size and in placement. For SVG output, it is used to guarantee that the dimensions in the output correspond to the correct number of points or inches.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="edgehref" type="escString" gv:formats="svg map">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Synonym for <a href="#edgeURL">edgeURL</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="edgetarget" type="escString" gv:formats="svg map">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the edge has a <a href="#URL">URL</a> or <a href="#edgeURL">edgeURL</a> attribute, this attribute determines which window of the browser is used for the URL attached to the non-label part of the edge. Setting it to "_graphviz" will open a new window if it doesn't already exist, or reuse it if it does. If undefined, the value of the <a href="#target">target</a> is used.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="edgetooltip" type="escString" gv:formats="svg cmap">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Tooltip annotation attached to the non-label part of an edge. This is used only if the edge has a <a href="#URL">URL</a> or <a href="#edgeURL">edgeURL</a> attribute.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="edgeURL" type="escString" gv:formats="svg map">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <a href="#edgeURL">edgeURL</a> is defined, this is the link used for the non-label parts of an edge. This value overrides any <a href="#URL">URL</a> defined for the edge. Also, this value is used near the head or tail node unless overridden by a <a href="#headURL">headURL</a> or <a href="#tailURL">tailURL</a> value, respectively. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="epsilon" type="double" gv:layouts="neato">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Terminating condition. If the length squared of all energy gradients are &lt; <a href="#epsilon">epsilon</a>, the algorithm stops.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="esep" type="double" gv:layouts="neato circo fdp">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Fraction to increase polygons (multiply coordinates by 1 + esep) for purposes of spline edge routing. This should normally be strictly less than <a href="#sep">sep</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="fillcolor" type="color">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Color used to fill the background of a node or cluster assuming <a href="#style">style</a<code>filled</code>. If <a href="#fillcolor">fillcolor</a> is not defined, <a href="#color">color</a> is used. (For clusters, if <a href="#color">color</a> is not defined, <a href="#bgcolor">bgcolor</a> is used.) If this is not defined, the default is used, except for <a href="#shape">shape</a><code>=point</code> or when the output format is MIF, which use black by default.
                </p>
                <p>
                    Note that a cluster inherits the root graph's attributes if defined. Thus, if the root graph has defined a <a href="#fillcolor">fillcolor</a>, this will override a <a href="#color">color</a> or <a href="#bgcolor">bgcolor</a> attribute set for the cluster.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="fixedsize" type="bool" default="false">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If true, the node size is specified by the values of the <a href="#width">width</a>  and <a href="#height">height</a> attributes only and is not expanded to contain the text label.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="fontcolor" type="color" default="black">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Color used for text.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="fontname" type="string" default="Times-Roman">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Font used for text. This very much depends on the output format and, for non-bitmap output such as PostScript or SVG, the availability of the font when the graph is displayed or printed. As such, it is best to rely on font faces that are generally available, such as Times-Roman, Helvetica or Courier.
                </p>
                <p>
                    If Graphviz was built using the <a href="http://pdx.freedesktop.org/~fontconfig/fontconfig-user.html">fontconfig library</a>, the latter library will be used to search for the font. However, if the <a href="#fontname">fontname</a> string contains a slash character "/", it is treated as a pathname for the font file, though font lookup will append the usual font suffixes.
                </p>
                <p>
                    If Graphviz does not use fontconfig, <a href="#fontname">fontname</a> will be considered the name of a Type 1 or True Type font file. If you specify <a href="#fontname">fontname</a><code>=schlbk</code>, the tool will look for a file named  <code>schlbk.ttf</code> or <code>schlbk.pfa</code> or <code>schlbk.pfb</code> in one of the directories specified by the <a href="#fontpath">fontpath</a> attribute. The lookup does support various aliases for the common fonts.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="fontnames" type="string" gv:formats="svg">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Allows user control of how basic fontnames are represented in SVG output. If <a href="#fontnames">fontnames</a> is undefined or <code>svg</code>, the output will try to use known SVG fontnames. For example, the default font <code>Times-Roman</code> will be mapped to the basic SVG font <code>serif</code>. This can be overridden by setting <a href="#fontnames">fontnames</a> to <code>ps</code> or <code>gd</code>. In the former case, known PostScript font names such as <code>Times-Roman</code> will be used in the output. In the latter case, the fontconfig font conventions are used. Thus, <code>Times-Roman</code> would be treated as <code>Nimbus Roman No9 L</code>. These last two options are useful with SVG viewers that support these richer fontname spaces.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="fontpath" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Directory list used by libgd to search for bitmap fonts if Graphviz was not built with the fontconfig library. If <a href="#fontpath">fontpath</a> is not set, the environment variable <code>DOTFONTPATH</code> is checked. If that is not set, <code>GDFONTPATH</code> is checked. If not set, libgd uses its compiled-in font path. Note that fontpath is an attribute of the root graph.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="fontsize" type="double" default="14.0">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Font size, in <a href="#points">points</a>, used for text.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    forcelabels
    gradientangle
    -->

    <xsd:attribute name="group" type="string" gv:layouts="dot">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the end points of an edge belong to the same group, i.e., have the same group attribute, parameters are set to avoid crossings and keep the edges straight.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="headclip" type="bool" default="true">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <code>true</code>, the head of an edge is clipped to the boundary of the head node; otherwise, the end of the edge goes to the center of the node, or the center of a port, if applicable.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="headhref" type="escString" gv:formats="svg map">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Synonym for <a href="#headURL">headURL</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="headlabel" type="lblString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Text label to be placed near head of edge. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="headport" type="portPos" default="center">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Indicates where on the head node to attach the head of the edge. In the default case, the edge is aimed towards the center of the node, and then clipped at the node boundary. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="headtarget" type="escString" gv:formats="svg map">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the edge has a <a href="#headURL">headURL</a>, this attribute determines which window of the browser is used for the URL. Setting it to "_graphviz" will open a new window if it doesn't already exist, or reuse it if it does. If undefined, the value of the <a href="#target">target</a> is used.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="headtooltip" type="escString" gv:formats="svg cmap">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Tooltip annotation attached to the head of an edge. This is used only if the edge has a <a href="#headURL">headURL</a> attribute.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="headURL" type="escString" gv:formats="svg map">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <a href="#headURL">headURL</a> is defined, it is output as part of the head label of the edge. Also, this value is used near the head node, overriding any <a href="#URL">URL</a> value. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="height" type="double" default="0.5">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Height of node, in inches. This is taken as the initial, minimum height of the node. If <a href="#fixedsize">fixedsize</a> is true, this will be the final height of the node. Otherwise, if the node label requires more height to fit, the node's height will be increased to contain the label. Note also that, if the output format is dot, the value given to <a href="#height">height</a> will be the final value.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="href" type="escString" gv:formats="svg ps ps2 map">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Synonym for <a href="#URL">URL</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    id
    -->

    <xsd:attribute name="image" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Gives the name of a file containing an image to be displayed inside a node. The image file must be in one of the recognized formats, typically JPEG, PNG, GIF or Postscript, and be able to be converted into the desired output format.
                </p>
                <p>
                    Unlike with the <a href="#shapefile">shapefile</a> attribute, the image is treated as node content rather than the entire node. In particular, an image can be contained in a node of any shape, not just a rectangle.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="imagepath" type="string" default="UTF-8">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies the path to images referenced within the graph.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    imagepos
    -->

    <xsd:attribute name="imagescale" type="string" default="false">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Attribute controlling how an image fills its containing node. In general, the image is given its natural size, (cf. <a href="#dpi">dpi</a>), and the node size is made large enough to contain its image, its label, its margin, and its peripheries. Its width and height will also be at least as large as its minimum <a href="#width">width</a> and <a href="#height">height</a>. If, however, <a href="#fixedsize">fixedsize</a><code>=true</code>, the width and height attributes specify the exact size of the node.
                </p>
                <p>
                    During rendering, in the default case (<a href="#imagescale">imagescale</a><code>=false</code>), the image retains its natural size. If <code>true</code>, the image is uniformly scaled (i.e., its aspect ratio is preserved) to fit inside the node. At least one dimension of the image will be as large as possible given the size of the node. When <code>width</code>, the width of the image is scaled to fill the node width. The corresponding property holds when <a href="#imagescale">imagescale</a><code>=height</code>. When <code>both</code>, both the height and the width are scaled separately to fill the node.
                </p>
                <p>
                    In all cases, if a dimension of the image is larger than the corresponding dimension of the node, that dimension of the image is scaled down to fit the node. As with the case of expansion, if <a href="#imagescale">imagescale</a><code>=true</code>, width and height are scaled uniformly.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    inputscale
    -->

    <xsd:attribute name="K" type="double" default="0.3" gv:layouts="fdp">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Spring constant used in virtual physical model. It roughly corresponds to an ideal edge length (in inches), in that increasing K tends to increase the distance between nodes. Note that the edge attribute <a href="#len">len</a> can be used to override this value for adjacent nodes.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="label" type="lblString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Text label attached to objects. If a node's <a href="#shape">shape</a> is <code>record</code>, then the label can have a <a href="https://www.graphviz.org/doc/info/shapes.html#record">special format</a> which describes the record layout.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    label_scheme
    -->

    <xsd:attribute name="labelangle" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This, along with <a href="#labeldistance">labeldistance</a>, determine where the headlabel (taillabel) are placed with respect to the head (tail) in polar coordinates. The origin in the coordinate system is the point where the edge touches the node. The ray of 0 degrees goes from the origin back along the edge, parallel to the edge at the origin.
                </p>
                <p>
                    The angle, in degrees, specifies the rotation from the 0 degree ray, with positive angles moving counterclockwise and negative angles moving clockwise.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labeldistance" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Multiplicative scaling factor adjusting the default distance (10 points) that the headlabel/taillabel is from the head/tail node. See <a href="#labelangle">labelangle</a> for more details.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labelfloat" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If true, allows edge labels to be less constrained in position. In particular, it may appear on top of other edges.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labelfontcolor" type="color">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Color used for headlabel and taillabel. If not set, defaults to edge's fontcolor.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labelfontname" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Font used for headlabel and taillabel. If not set, defaults to edge's fontname.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labelfontsize" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Font size, in <a href="#points">points</a>, used for headlabel and taillabel. If not set, defaults to edge's fontsize.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labelhref" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Synonym for <a href="#labelURL">labelURL</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labeljust" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Justification for cluster labels. If <code>r</code>, the label is right-justified within bounding rectangle; if <code>l</code>, left-justified; else the label is centered. Note that a subgraph inherits attributes from its parent. Thus, if the root graph sets <a href="#labeljust">labeljust</a> to <code>l</code>, the subgraph inherits this value.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labelloc" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Top/bottom placement of graph and cluster labels. If the attribute is <code>t</code>, place label at the top; if the attribute is <code>b</code>, place label at the bottom. By default, root graph labels go on the bottom and cluster labels go on the top. Note that a subgraph inherits attributes from its parent. Thus, if the root graph sets <a href="#labelloc">labelloc</a> to <code>b</code>, the subgraph inherits this value.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labeltarget" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the edge has a <a href="#URL">URL</a> or <a href="#labelURL">labelURL</a> attribute, this attribute determines which window of the browser is used for the URL attached to the label. Setting it to "_graphviz" will open a new window if it doesn't already exist, or reuse it if it does. If undefined, the value of the <a href="#target">target</a> is used.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labeltooltip" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Tooltip annotation attached to label of an edge. This is used only if the edge has a <a href="#URL">URL</a> or <a href="#labelURL">labelURL</a> attribute.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="labelURL" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <a href="#labelURL">labelURL</a> is defined, this is the link used for the label of an edge. This value overrides any <a href="#URL">URL</a> defined for the edge.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="landscape" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If true, the graph is rendered in landscape mode. Synonymous with <a href="#rotate">rotate</a><a href="#"></a><code>=90</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="layer" type="layerRange">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies layers in which the node or edge is present.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    layerlistsep
    -->

    <xsd:attribute name="layers" type="layerList">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies a linearly ordered list of layer names attached to the graph The graph is then output in separate layers. Only those components belonging to the current output layer appear. For more information, see the page <a href="https://www.graphviz.org/faq/#FaqOverlays">How to use drawing layers (overlays)</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    layerlistselect
    -->

    <xsd:attribute name="layersep" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies the separator characters used to split the <a href="#layers">layers</a> attribute into a list of layer names.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="layout" type="layoutEngine">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies the name of the layout algorithm to use, such as <code>dot</code> or <code>neato</code>. Normally, graphs should be kept independent of a type of layout. In some cases, however, it can be convenient to embed the type of layout desired within the graph. For example, a graph containing position information from a layout might want to record what the associated layout algorithm was.
                </p>
                <p>
                    This attribute takes precedence over the <a href="https://www.graphviz.org/doc/info/command.html#minusK">-K flag</a> or the actual command name used.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="len" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Preferred edge length, in inches.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    levels
    -->

    <xsd:attribute name="levelsgap" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies strictness of level constraints in neato when <a href="#mode">mode</a><a href="#"></a><code>=ipsep</code> or <code>hier</code>. Larger positive values mean stricter constraints, which demand more separation between levels. On the other hand, negative values will relax the constraints by allowing some overlap between the levels.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="lhead" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Logical head of an edge. When <a href="#compound">compound</a> is true, if <a href="#lhead">lhead</a> is defined and is the name of a cluster containing the real head, the edge is clipped to the boundary of the cluster. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    lheight
    -->

    <xsd:attribute name="lp" type="point">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Label position, in <a href="#points">points</a>. The position indicates the center of the label.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="ltail" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Logical tail of an edge. When <a href="#compound">compound</a> is true, if <a href="#ltail">ltail</a> is defined and is the name of a cluster containing the real tail, the edge is clipped to the boundary of the cluster. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    lwidth
    -->

    <xsd:attribute name="margin" type="point">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    For graphs, this sets x and y margins of canvas, in inches. If the margin is a single value, both margins are set equal to the given value.
                </p>
                <p>
                    Note that the margin is not part of the drawing but just empty space left around the drawing. It basically corresponds to a translation of drawing, as would be necessary to center a drawing on a page. Nothing is actually drawn in the margin. To actually extend the background of a drawing, see the <a href="#pad">pad</a> attribute.
                </p>
                <p>
                    For nodes, this attribute specifies space left around the node's label. By default, the value is <code>0.11,0.055</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="maxiter" type="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Sets the number of iterations used.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="mclimit" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Multiplicative scale factor used to alter the MinQuit (default = 8) and MaxIter (default = 24) parameters used during crossing minimization. These correspond to the number of tries without improvement before quitting and the maximum number of iterations in each pass.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="mindist" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies the minimum separation between all nodes.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="minlen" type="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Minimum edge length (rank difference between head and tail).
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="mode" type="modeType" gv:layouts="neato">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Technique for optimizing the layout
                </p>
                <p>
                    <code>neato</code> supports modes:
                    <ul>
                        <li>
                            <a href="#mode">mode</a><code>=major</code>: uses stress majorization.
                        </li>
                        <li>
                            <a href="#mode">mode</a><code>=KK</code>: uses the Kamada-Kawai version of the gradient descent method. <code>KK</code> is sometimes appreciably faster for small (number of nodes &lt; 100) graphs. A significant disadvantage is that <code>KK</code> may cycle.
                        </li>
                        <li>
                            <a href="#mode">mode</a><code>=sgd</code>: uses a version of the Stochastic Gradient Descent method. <code>sgd</code>'s advantage is faster and more reliable convergence than both the previous methods, while <code>sgd</code>'s disadvantage is that it runs in a fixed number of iterations and may require larger values of <a href="#maxiter">maxiter</a> in some graphs.
                        </li>
                    </ul>
                </p>
                <p>
                    There are two new, experimental modes in <code>neato</code>
                    <ul>
                        <li>
                            <a href="#mode">mode</a><code>=heir</code>: uses a top-down directionality similar to the layout used in dot
                        </li>
                        <li>
                            <a href="#mode">mode</a><code>=ipsep</code>: uses the graph to specify minimum vertical and horizontal distances between nodes. (See the <a href="#sep">sep</a> attribute.)
                        </li>
                    </ul>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="model" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This value specifies how the distance matrix is computed for the input graph. The distance matrix specifies the ideal distance between every pair of nodes. neato attemps to find a layout which best achieves these distances. By default, it uses the length of the shortest path, where the length of each edge is given by its <a href="#len">len</a> attribute. If <a href="#model">model</a> is <code>circuit</code>, neato uses the circuit resistance model to compute the distances. This tends to emphasize clusters. If <a href="#model">model</a> is <code>subset</code>, neato uses the subset model. This sets the edge length to be the number of nodes that are neighbors of exactly one of the end points, and then calculates the shortest paths. This helps to separate nodes with high degree.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    newrank
    -->

    <xsd:attribute name="nodesep" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Minimum space between two adjacent nodes in the same rank, in inches.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="nojustify" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    By default, the justification of multi-line labels is done within the largest context that makes sense. Thus, in the label of a polygonal node, a left-justified line will align with the left side of the node (shifted by the prescribed <a href="#margin">margin</a>). In record nodes, left-justified line will line up with the left side of the enclosing column of fields. If <a href="#nojustify">nojustify</a> is <code>true</code>, multi-line labels will be justified in the context of itself. For example, if the attribute is set, the first label line is long, and the second is shorter and left-justified, the second will align with the left-most character in the first line, regardless of  how large the node might be.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="normalize" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If set, normalize coordinates of final layout so that the first point is at the origin, and then rotate the layout so that the first edge is horizontal.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    notranslate
    -->

    <xsd:attribute name="nslimit" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Used to set number of iterations in network simplex applications, used in computing node x coordinates. If defined, # iterations =  <a href="#nslimit">nslimit</a> * # nodes; otherwise,  # iterations = MAXINT.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="nslimit1" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Used to set number of iterations in network simplex applications, used for ranking nodes. If defined, # iterations =  <a href="#nslimit1">nslimit1</a> * # nodes; otherwise,  # iterations = MAXINT.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    oneblock
    -->

    <xsd:attribute name="ordering" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If "out" for a graph G, and n is a node in G, then edges n-&gt;* appear left-to-right in the same order in which they are defined. If "in", the edges *-&gt;n appear left-to-right in the same order in which they are defined for all nodes n.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="orientation" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Angle, in degrees, used to rotate node shapes.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>
    <!--
    <xsd:attribute name="orientation" type="string" default="L">
    <xsd:annotation>
    <xsd:documentation>
    <![CDATA[
    If "[lL]*", set graph orientation to landscape
    Used only if <a href="#rotate">rotate</a> is not defined.
    ]]>
    </xsd:documentation>
    </xsd:annotation>
    </xsd:attribute>
    -->
    <xsd:attribute name="outputorder" type="outputMode">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specify order in which nodes and edges are drawn.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="overlap" type="overlapTechnique" gv:layouts="fdp neato sfdp circo twopi">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Determines if and how node overlaps should be removed
                </p>
                <p>
                    Nodes are first enlarged using the <a href="#sep">sep</a> attribute. If <code>true</code>, overlaps are retained. If the value is <code>scale</code>, overlaps are removed by uniformly scaling in x and y. If the value converts to <code>false</code> and Prism (a proximity graph-based algorithm) is available, it is used to remove node overlaps. This can also be invoked explicitly with <a href="#overlap">overlap</a><code>=prism</code>. This technique starts with a small scaling up, controlled by the <a href="#overlap_scaling">overlap_scaling</a> attribute, which can remove a significant portion of the overlap. The prism option also accepts an optional non-negative integer suffix. This can be used to control the number of attempts made at overlap removal. By default, <a href="#overlap">overlap</a><code>=prism</code> is equivalent to <a href="#overlap">overlap</a><code>=prism1000</code>. Setting <a href="#overlap">overlap</a><code>=prism0</code> causes only the scaling phase to be run.
                </p>
                <p>
                    If Prism is not available, <a href="#overlap">overlap</a><code>=false</code> node overlaps are removed by a Voronoi-based technique. This can always be invoked explicitly with <a href="#overlap">overlap</a><code>=voronoi</code>.
                </p>
                <p>
                    If the value is <code>scalexy</code>, x and y are separately scaled to remove overlaps.
                </p>
                <p>
                    If <a href="#overlap">overlap</a><code>=compress</code>, the layout will be scaled down as much as possible without introducing any overlaps, obviously assuming there are none to begin with.
                </p>
                <p>
                    <b>N.B.</b> The remaining allowed values of <code>overlap</code> correspond to algorithms which, at present, can produce bad aspect ratios. In addition, we deprecate the use of the <code>ortho*</code> and <code>portho*</code>.
                </p>
                <p>
                    If the value is <code>vpsc</code>, overlap removal is done as a quadratic optimization is used to minimize node displacement while removing node overlaps.
                </p>
                <p>
                    If the value is <code>orthoxy</code> or <code>orthoyx</code>, overlaps are moved by optimizing two constraint problems, one for the x axis and one for the y. The suffix indicates which axis is processed first. If the value is <code>ortho</code>, the technique is similar to <code>orthoxy</code> except a heuristic is used to reduce the bias between the two passes. If the value is <code>ortho_yx</code>, the technique is the same as <code>ortho</code>, except the roles of x and y are reversed. The values <code>portho</code>, <code>porthoxy</code>, <code>porthoxy</code>, and <code>portho_yx</code> are similar to the previous four, except only pseudo-orthogonal ordering is enforced.
                </p>
                <p>
                    If the layout is done by <code>neato</code> with <a href="#mode">mode</a><a href="#"></a><code>=ipsep</code>, then one can use <a href="#overlap">overlap</a><code>=ipsep</code>. In this case, the overlap removal constraints are incorporated into the layout algorithm itself. N.B. At present, this only supports one level of clustering.
                </p>
                <p>
                    Except for <code>fdp</code> and <code>sfdp</code>, the layouts assume <a href="#overlap">overlap</a><code>=true</code> as the default. Fdp first uses a number of passes using built-in, force-directed technique to remove overlaps. Thus, <code>fdp</code> accepts <a href="#overlap">overlap</a> with an integer prefix followed by a colon, specifying the number of tries. If there is no prefix, no initial tries will be performed. If there is nothing following a colon, none of the above methods will be attempted. By default, <code>fdp</code> uses <a href="#overlap">overlap</a><code>=9:prism</code>. Note that <a href="#overlap">overlap</a><code>="true"</code>, <a href="#overlap">overlap</a><code>=0:true</code> and <a href="#overlap">overlap</a><code>=0:</code> all turn off all overlap removal.
                </p>
                <p>
                    By default, <code>sfdp</code> uses <a href="#overlap">overlap</a><code>=prism0</code>.
                </p>
                <p>
                    Except for the Voronoi method, all of these transforms preserve the orthogonal ordering of the original layout. That is, if the x coordinates of two nodes are originally the same, they will remain the same, and if the x coordinate of one node is originally less than the x coordinate of another, this relation will still hold in the transformed layout. The similar properties hold for the y coordinates. This is not quite true for the <code>porth*</code> cases. For these, orthogonal ordering is only preserved among nodes related by an edge.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    overlap_scaling
    overlap_shrink
    -->

    <xsd:attribute name="pack" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This is true if the value of pack is <code>true</code> (case-insensitive) or a non-negative integer. If true, each connected component of the graph is laid out separately, and then the graphs are packed tightly. If pack has an integral value, this is used as the size, in <a href="#points">points</a>, of a margin around each part; otherwise, a default margin of 8 is used. If pack is interpreted as false, the entire graph is laid out together. The granularity and method of packing is influenced by the <a href="#packmode">packmode</a> attribute.
                </p>
                <p>
                    For layouts which always do packing, such a twopi, the <a href="#pack">pack</a> attribute is just used to set the margin.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="packmode" type="packMode">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This indicates the granularity and method used for packing (cf. <a href="#packMode">packMode</a>). Note that defining <a href="#packmode">packmode</a> will automatically turn on packing as though one had set <a href="#pack">pack</a><code>=true</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="pad" type="point">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    The pad attribute specifies how much, in inches, to extend the drawing area around the minimal area needed to draw the graph. If the pad is a single value, both the x and y pad values are set equal to the given value. This area is part of the drawing and will be filled with the background color, if appropriate.
                </p>
                <p>
                    Normally, a small pad is used for aesthetic reasons, especially when a background color is used, to avoid having nodes and edges abutting the boundary of the drawn region.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="page" type="point">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Width and height of output pages, in inches. If this is set and is smaller than the size of the layout, a rectangular array of pages of the specified page size is overlaid on the layout, with origins aligned in the lower-left corner, thereby partitioning the layout into pages. The pages are then produced one at a time, in <a href="#pagedir">pagedir</a> order.
                </p>
                <p>
                    At present, this only works for PostScript output. For other types of output, one should use another tool to split the output into multiple output files. Or use the <a href="#viewport">viewport</a> to generate multiple files.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="pagedir" type="pagedir">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the <a href="#page">page</a> attribute is set and applicable, this attribute specifies the order in which the pages are emitted. This is limited to one of the 8 row or column major orders.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="pencolor" type="color">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Color used to draw the bounding box around a cluster. If <a href="#pencolor">pencolor</a> is not defined, <a href="#color">color</a> is used. If this is not defined, <a href="#bgcolor">bgcolor</a> is used. If this is not defined, the default is used.
                </p>
                <p>
                    Note that a cluster inherits the root graph's attributes if defined. Thus, if the root graph has defined a <a href="#pencolor">pencolor</a>, this will override a <a href="#color">color</a> or <a href="#bgcolor">bgcolor</a> attribute set for the cluster.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="penwidth" type="double" default="1.0">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies the width of the pen, in points, used to draw lines and curves
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="peripheries" type="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Set number of peripheries used in polygonal shapes and cluster boundaries. Note that <a href="https://www.graphviz.org/doc/info/shapes.html#epsf">user-defined shapes</a> are treated as a form of box shape, so the default peripheries value is 1 and the user-defined shape will be drawn in a bounding rectangle. Setting <a href="#peripheries">peripheries</a><code>=0</code> will turn this off. Also, 1 is the maximum peripheries value for clusters.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="pin" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If true and the node has a pos attribute on input, neato prevents the node from moving from the input position. This property can also be specified in the pos attribute itself (cf. the <a href="#point">point</a> type).
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="pos" type="splineType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Position of node, or spline control points. For nodes, the position indicates the center of the node. On output, the coordinates are in <a href="#points">points</a>.
                </p>
                <p>
                    In neato and fdp, pos can be used to set the initial position of a node. By default, the coordinates are assumed to be in inches. However, the <a href="https://www.graphviz.org/doc/info/command.html#d:s">-s</a> command line flag can be used to specify different units.
                </p>
                <p>
                    When the <a href="https://www.graphviz.org/doc/info/command.html#d:n">-n</a> command line flag is used with neato, it is assumed the positions have been set by one of the layout programs, and are therefore in points. Thus, <code>neato -n</code> can accept input correctly without requiring a <code>-s</code> flag and, in fact, ignores any such flag.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    quadtree
    radius
    -->

    <xsd:attribute name="quantum" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <a href="#quantum">quantum</a> &gt; 0.0, node label dimensions will be rounded to integral multiples of the quantum.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="rank" type="rankType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Rank constraints on the nodes in a subgraph
                </p>
                <p>
                    <table><tbody>
                        <tr>
                            <td><code>same</code></td>
                            <td>all nodes placed on the same rank</td>
                        </tr>
                        <tr>
                            <td><code>min</code></td>
                            <td>all nodes placed on the minimum rank</td>
                        </tr>
                        <tr>
                            <td><code>source</code></td>
                            <td>all nodes placed on the minimum rank, and the only nodes on the minimum rank belong to some subgraph whose rank attribute is <code>source</code> or <code>min</code></td>
                        </tr>
                        <tr>
                            <td><code>max</code></td>
                            <td>all nodes placed on the maximum rank</td>
                        </tr>
                        <tr>
                            <td><code>sink</code></td>
                            <td>all nodes placed on the maximum rank, and the only nodes on the maximum rank belong to some subgraph whose rank attribute is <code>sink</code> or <code>max</code></td>
                        </tr>
                    </tbody></table>
                </p>
                <p>
                    Note: the minimum rank is topmost or leftmost, and the maximum rank is bottommost or rightmost.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="rankdir" type="rankdir">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Sets direction of graph layout. For example, if <a href="#rankdir">rankdir</a><a href="#"></a><code>=LR</code>, and barring cycles, an edge <code>T -&gt; H;</code> will go from left to right. By default, graphs are laid out from top to bottom.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="ranksep" type="doubleList" default="0.5" gv:layouts="dot twopi">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Specifies separation between ranks
                </p>
                <p>
                    type: <a href="#double">double</a> | <a href="#doubleList">doubleList</a>, default: 0.5 (dot), 1.0 (twopi), minimum: 0.02
                </p>
                <p>
                    In dot, sets the desired rank separation, in inches. This is the minimum vertical distance between the bottom of the nodes in one rank and the tops of nodes in the next. If the value contains "equally", the centers of all ranks are spaced equally apart. Note that both settings are possible, e.g., <code>ranksep = "1.2 equally"</code>.
                </p>
                <p>
                    In twopi, specifies radial separation of concentric circles. For twopi, ranksep can also be a list of double values. The first value specifies the radius of the inner circle; the second value specifies the increase in radius from the first circle to the second; etc. If there are more circles than numbers, the last number is used as the increment for the remainder.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="ratio" type="ratioType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Sets the aspect ratio (drawing height/drawing width) for the drawing. Note that this is adjusted before the <a href="#size">size</a> attribute constraints are enforced.
                </p>
                <p>
                    Note that <code>fill, compress, expand</code> settings depend on <a href="#size">size</a> being set.
                </p>
                <p>
                    <table><tbody>
                        <tr>
                            <td><code>fill</code></td>
                            <td>
                                Node positions are scaled separately in both x and y so that the final drawing exactly fills the specified size.
                            </td>
                        </tr>
                        <tr>
                            <td><code>compress</code></td>
                            <td>
                                This feature only works in dot, which attempts to compress the initial layout to fit in the given size. This achieves a tighter packing of nodes but reduces the balance and symmetry.
                            </td>
                        </tr>
                        <tr>
                            <td><code>expand</code></td>
                            <td>
                                If both width and height of graph are less than <a href="#size">size</a>, node positions are scaled uniformly until at least one dimension fits exactly. Note that this is distinct from using <a href="#size">size</a> as the desired size, as here the drawing is expanded before edges are generated and all node and text sizes remain unchanged.
                            </td>
                        </tr>
                        <tr>
                            <td><code>auto</code></td>
                            <td>
                                If <a href="#page">page</a> is set and graph cannot be drawn on single page, then <a href="#size">size</a> is set to an "ideal" value. In particular, the size in a given dimension will be the smallest integral multiple of the page size in that dimension which is at least half the current size. The two dimensions are then scaled independently to the new size. This feature only works in dot.
                            </td>
                        </tr>
                    </tbody></table>
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="rects" type="rect">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Rectangles for fields of records, in <a href="#points">points</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="regular" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If true, force polygon to be regular.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="remincross" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If true and there are multiple clusters, run cross minimization a second time.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    repulsiveforce
    -->

    <xsd:attribute name="resolution" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This is a synonym for the <a href="#dpi">dpi</a> attribute.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="root" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    This specifies nodes to be used as the center of the layout and the root of the generated spanning tree. As a graph attribute, this gives the name of the node. As a node attribute (circo only), it specifies that the node should be used as a central node. In twopi, this will actually be the central node. In circo, the block containing the node will be central in the drawing of its connected component. If not defined, twopi will pick a most central node, and circo will pick a random node.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="rotate" type="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If 90, set drawing orientation to landscape.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    rotation
    -->

    <xsd:attribute name="samehead" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Edges with the same head and the same <a href="#samehead">samehead</a> value are aimed at the same point on the head. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="sametail" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Edges with the same tail and the same <a href="#sametail">sametail</a> value are aimed at the same point on the tail. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="samplepoints" type="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the input graph defines the <a href="#vertices">vertices</a> attribute, and output is dot or xdot, this gives the number of points used for a node whose shape is a circle or ellipse. It plays the same role in neato, when adjusting the layout to avoid overlapping nodes, and in image maps.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="searchsize" type="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    During network simplex, maximum number of edges with negative cut values to search when looking for one with minimum cut value.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="sep" type="point">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Fraction to increase polygons (multiply coordinates by 1 + sep) for purposes of determining overlap. Guarantees a minimal non-zero distance between nodes. If unset but <a href="#esep">esep</a> is defined, <a href="#sep">sep</a> will be set to <code>esep/0.8</code>. If <a href="#esep">esep</a> is unset, the default value is used.
                </p>
                <p>
                    When <a href="#overlap">overlap</a><a href="#"></a><code>=ipsep</code> or <code>vpsc</code>, <a href="#sep">sep</a> gives a minimum distance, in inches, to be left between nodes. In this case, if <a href="#sep">sep</a> is a <a href="#point">point</a>, the x and y separations can be specified separately.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="shape" type="shapeType">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Set the shape of a node.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="shapefile" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    (Deprecated)
                </p>
                <p>
                </p>
                Sets the node's <a href="#shape">shape</a><code>=box</code>. The image in the shapefile must be rectangular. The image formats supported as well as the precise semantics of how the file is used depends on the <a href="https://www.graphviz.org/docs/outputs/">output format</a>. For further details, see <a href="https://www.graphviz.org/faq/#ext_image">External PostScript files</a>.
                </p>
                <p>
                    There is one exception to this usage. If <a href="#shape">shape</a><code>=epsf</code>, <a href="#shapefile">shapefile</a> gives a filename containing a definition of the node in PostScript. The graphics defined must contain all of the node content, including any desired boundaries. For further details, see <a href="https://www.graphviz.org/faq/#ext_ps_file">External PostScript files</a>.
                </p>
                <p>
                    Only paths to local resources are supported. If you want to use a URL to a remote resource, see the <a href="https://gitlab.com/graphviz/graphviz/-/blob/main/contrib/dot_url_resolve.py">dot_url_resolve.py</a> script.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="showboxes" type="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Print guide boxes in PostScript at the beginning of routesplines if 1, or at the end if 2. (Debugging)
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="sides" type="int">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Number of sides if <a href="#shape">shape</a><a href="#"></a><code>=polygon</code>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="size" type="point">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Maximum width and height of drawing, in inches. If defined and the drawing is too large, the drawing is uniformly scaled down so that it fits within the given size.
                </p>
                <p>
                    If <a href="#size">size</a> ends in an exclamation point (<code>!</code>), then it is taken to be the desired size. In this case, if both dimensions of the drawing are less than <a href="#size">size</a>, the drawing is scaled up uniformly until at least one dimension equals its dimension in <a href="#size">size</a>.
                </p>
                <p>
                    Note that there is some interaction between the <a href="#size">size</a> and <a href="#ratio">ratio</a> attributes.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="skew" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Skew factor for <a href="#shape">shape</a><code>=polygon</code>. Positive values skew top of polygon to right; negative to left.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    smoothing
    sortv
    -->

    <xsd:attribute name="splines" type="string">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Controls how, and if, edges are represented. If true, edges are drawn as splines routed around nodes; if false, edges are drawn as line segments. If set to "", no edges are drawn at all.
                </p>
                <p>
                    The values <a href="#splines">splines</a><code>=line</code> and <a href="#splines">splines</a><code>=spline</code> can be used as synonyms for <a href="#splines">splines</a><code>=false</code> and <a href="#splines">splines</a><code>=true</code>, respectively. In addition, <a href="#splines">splines</a><code>=polyline</code> specifies that edges should be drawn as polylines.
                </p>
                <p>
                    <a href="#splines">splines</a><code>=ortho</code> specifies edges should be routed as polylines of axis-aligned segments. Currently, the routing does not handle ports or, in dot, edge labels.
                </p>
                <p>
                    <a href="#splines">splines</a><code>=curved</code> specifies edges should be drawn as curved arcs.
                </p>
                <p>
                    By default, the attribute is unset. How this is interpreted depends on the layout. For dot, the default is to draw edges as splines. For all other layouts, the default is to draw edges as line segments. Note that for these latter layouts, if <a href="#splines">splines</a><code>=true</code>, this requires non-overlapping nodes (cf. <a href="#overlap">overlap</a>). If fdp is used for layout and <a href="#splines">splines</a><code>=compound</code>, then the edges are drawn to avoid clusters as well as nodes.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="start" type="startType" gv:layouts="neato fdp sfdp">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Parameter used to determine the initial layout of nodes. If unset, the nodes are randomly placed in a unit square with the same seed is always used for the random number generator, so the initial placement is repeatable.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="style" type="style">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Set style for node or edge. For cluster subgraph, if "filled", the cluster box's background is filled.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="stylesheet" type="string" gv:formats="svg">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    A URL or pathname specifying an XML style sheet, used in SVG output.
                </p>
                <p>
                    Combine with <a href="#class">class</a> to style elements using CSS selectors.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="tail_lp" type="point">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Position of an edge's tail label, in <a href="#point">points</a>.
                </p>
                <p>
                    The position indicates the center of the label.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="tailclip" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <code>true</code>, the tail of an edge is clipped to the boundary of the tail node; otherwise, the end of the edge goes to the center of the node, or the center of a port, if applicable.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="tailhref" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Synonym for <a href="#tailURL">tailURL</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="taillabel" type="lblString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Text label to be placed near tail of edge. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="tailport" type="portPos">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Indicates where on the tail node to attach the tail of the edge. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="tailtarget" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the edge has a <a href="#tailURL">tailURL</a>, this attribute determines which window of the browser is used for the URL. Setting it to "_graphviz" will open a new window if it doesn't already exist, or reuse it if it does. If undefined, the value of the <a href="#target">target</a> is used.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="tailtooltip" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Tooltip annotation attached to the tail of an edge. This is used only if the edge has a <a href="#tailURL">tailURL</a> attribute.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="tailURL" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If <a href="#tailURL">tailURL</a> is defined, it is output as part of the tail label of the edge. Also, this value is used near the tail node, overriding any <a href="#URL">URL</a> value. See <a href="#undirected">undirected</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="target" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the object has a URL, this attribute determines which window of the browser is used for the URL. See <a href="http://www.w3.org/TR/html401/present/frames.html#adef-target">W3C documentation</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    TBbalance
    -->

    <xsd:attribute name="tooltip" type="escString">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Tooltip annotation attached to the node or edge. If unset, Graphviz will use the object's <a href="#label">label</a> if defined. Note that if the label is a record specification or an HTML-like label, the resulting tooltip may be unhelpful. In this case, if tooltips will be generated, the user should set a <code>tooltip</code> attribute explicitly.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="truecolor" type="bool">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If set explicitly to true or false, the value determines whether or not internal bitmap rendering relies on a truecolor color model or uses a color palette. If the attribute is unset, truecolor is not used unless there is a <a href="#shapefile">shapefile</a> property for some node in the graph. The output model will use the input model when possible.
                </p>
                <p>
                    Use of color palettes results in less memory usage during creation of the bitmaps and smaller output files.
                </p>
                <p>
                    Usually, the only time it is necessary to specify the truetype model is if the graph uses more than 256 colors. However, if one uses <a href="#bgcolor">bgcolor</a><code>=transparent</code> with a color palette, font antialiasing can show up as a fuzzy white area around characters. Using <a href="#truecolor">truecolor</a><code>=true</code> avoids this problem.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="URL" type="escString" gv:formats="svg ps ps2 map">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Hyperlinks incorporated into device-dependent output. At present, used in ps2, cmap, i*map and svg formats. For all these formats, URLs can be attached to nodes, edges and clusters. URL attributes can also be attached to the root graph in ps2, cmap and i*map formats. This serves as the base URL for relative URLs in the former, and as the default image map file in the latter.
                </p>
                <p>
                    For svg, cmapx and imap output, the active area for a node is its visible image. For example, an unfilled node with no drawn boundary will only be active on its label. For other output, the active area is its bounding box. The active area for a cluster is its bounding box. For edges, the active areas are small circles where the edge contacts its head and tail nodes. In addition, for svg, cmapx and imap, the active area includes a thin polygon approximating the edge. The circles may overlap the related node, and the edge URL dominates. If the edge has a label, this will also be active. Finally, if the edge has a head or tail label, this will also be active.
                </p>
                <p>
                    Note that, for edges, the attributes <a href="#headURL">headURL</a>, <a href="#tailURL">tailURL</a>, <a href="#labelURL">labelURL</a> and <a href="#edgeURL">edgeURL</a> allow control of various parts of an edge. Also note that, if active areas of two edges overlap, it is unspecified which area dominates.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="vertices" type="pointList">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    If the input graph defines this attribute, the node is polygonal, and output is dot or xdot, this attribute provides the coordinates of the vertices of the node's polygon, in inches. If the node is an ellipse or circle, the <a href="#samplepoints">samplepoints</a> attribute affects the output.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="viewport" type="viewPort">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Clipping window on final drawing.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="voro_margin" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Factor to scale up drawing to allow margin for expansion in Voronoi technique. dim' = (1+2*margin)*dim.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="weight" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Weight of edge. In dot, the heavier the weight, the shorter, straighter and more vertical the edge is. In neato, the heavier the weight, the more neato will try to place the end points so that the length of the edge is <a href="#len">len</a>.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="width" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Width of node, in inches. This is taken as the initial, minimum width of the node. If <a href="#fixedsize">fixedsize</a> is true, this will be the final width of the node. Otherwise, if the node label requires more width to fit, the node's width will be increased to contain the label. Note also that, if the output format is dot, the value given to <a href="#width">width</a> will be the final value.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!--
    xdotversion
    xlabel
    xlp
    -->

    <xsd:attribute name="z" type="double">
        <xsd:annotation>
            <xsd:documentation>
            <![CDATA[
                <p>
                    Provides z coordinate value for 3D layouts and displays. If the graph has <a href="#dim">dim</a> set to 3 (or more), neato will use a node's <a href="#z">z</a> value for the z coordinate of its initial position if its <a href="#pos">pos</a> attribute is also defined.
                </p>
                <p>
                    Even if no <a href="#z">z</a> values are specified in the input, it is necessary to declare a <a href="#z">z</a> attribute for nodes, e.g, using <code>node[z=""]</code> in order to get z values on output. Thus, setting <a href="#dim">dim</a><code>=3</code> but not declaring <a href="#z">z</a> will cause <code>neato -Tvrml</code> to layout the graph in 3D but project the layout onto the xy-plane for the rendering. If the <a href="#z">z</a> attribute is declared, the final rendering will be in 3D.
                </p>
            ]]>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <!-- COMPONENTS -->

    <xsd:complexType name="edge">
        <xsd:attribute ref="arrowhead" default="normal" />
        <xsd:attribute ref="arrowsize" default="1.0" />
        <xsd:attribute ref="arrowtail" default="normal" />
        <xsd:attribute ref="class" />
        <xsd:attribute ref="color" default="black" />
        <xsd:attribute ref="colorscheme" />
        <xsd:attribute ref="comment" />
        <xsd:attribute ref="constraint" default="true" />
        <xsd:attribute ref="decorate" default="false" />
        <xsd:attribute ref="dir" />
        <xsd:attribute ref="edgehref" />
        <xsd:attribute ref="edgetarget" />
        <xsd:attribute ref="edgetooltip" />
        <xsd:attribute ref="edgeURL" />
        <xsd:attribute ref="fillcolor" default="black" />
        <xsd:attribute ref="fontcolor" default="black" />
        <xsd:attribute ref="fontname" default="Times-Roman" />
        <xsd:attribute ref="fontsize" default="14.0" />
        <xsd:attribute ref="head_lp" />
        <xsd:attribute ref="headclip" default="true" />
        <xsd:attribute ref="headhref" />
        <xsd:attribute ref="headlabel" />
        <xsd:attribute ref="headport" default="center" />
        <xsd:attribute ref="headtarget" />
        <xsd:attribute ref="headtooltip" />
        <xsd:attribute ref="headURL" />
        <xsd:attribute ref="href" />
        <xsd:attribute ref="id" />
        <xsd:attribute ref="label" />
        <xsd:attribute ref="labelURL" />
        <xsd:attribute ref="labelangle" default="-25.0" />
        <xsd:attribute ref="labeldistance" default="1.0" />
        <xsd:attribute ref="labelfloat" default="false" />
        <xsd:attribute ref="labelfontcolor" default="black" />
        <xsd:attribute ref="labelfontname" default="Times-Roman" />
        <xsd:attribute ref="labelfontsize" default="14.0" />
        <xsd:attribute ref="labelhref" />
        <xsd:attribute ref="labeltarget" />
        <xsd:attribute ref="labeltooltip" />
        <xsd:attribute ref="labelURL" />
        <xsd:attribute ref="layer" />
        <xsd:attribute ref="len" />
        <xsd:attribute ref="lhead" />
        <xsd:attribute ref="lp" />
        <xsd:attribute ref="ltail" />
        <xsd:attribute ref="minlen" default="1" />
        <xsd:attribute ref="nojustify" default="false" />
        <xsd:attribute ref="penwidth" />
        <xsd:attribute ref="pos" />
        <xsd:attribute ref="radius" default="0.0" />
        <xsd:attribute ref="samehead" />
        <xsd:attribute ref="sametail" />
        <xsd:attribute ref="showboxes" default="0" />
        <xsd:attribute ref="style" />
        <xsd:attribute ref="tail_lp" />
        <xsd:attribute ref="tailclip" default="true" />
        <xsd:attribute ref="tailhref" />
        <xsd:attribute ref="taillabel" />
        <xsd:attribute ref="tailport" default="center" />
        <xsd:attribute ref="tailtarget" />
        <xsd:attribute ref="tailtooltip" />
        <xsd:attribute ref="tailURL" />
        <xsd:attribute ref="target" />
        <xsd:attribute ref="tooltip" />
        <xsd:attribute ref="URL" />
        <xsd:attribute ref="weight" default="1.0" />
        <xsd:attribute ref="xlabel" />
        <xsd:attribute ref="xlp" />
    </xsd:complexType>

    <xsd:complexType name="node">
        <xsd:attribute ref="area" />
        <xsd:attribute ref="class" />
        <xsd:attribute ref="color" default="black" />
        <xsd:attribute ref="colorscheme" />
        <xsd:attribute ref="comment" />
        <xsd:attribute ref="distortion" default="0.0" />
        <xsd:attribute ref="fillcolor" default="lightgrey" />
        <xsd:attribute ref="fixedsize" default="false" />
        <xsd:attribute ref="fontcolor" default="black" />
        <xsd:attribute ref="fontname" default="Times-Roman" />
        <xsd:attribute ref="fontsize" default="14.0" />
        <xsd:attribute ref="gradientangle" default="0" />
        <xsd:attribute ref="group" />
        <xsd:attribute ref="height" default="0.5" />
        <xsd:attribute ref="href" />
        <xsd:attribute ref="id" />
        <xsd:attribute ref="image" />
        <xsd:attribute ref="imagepos" default="mc" />
        <xsd:attribute ref="imagescale" default="false" />
        <xsd:attribute ref="label" default="\N" />
        <xsd:attribute ref="labelloc" default="c" />
        <xsd:attribute ref="layer" />
        <xsd:attribute ref="margin" />
        <xsd:attribute ref="nojustify" default="false" />
        <xsd:attribute ref="ordering" />
        <xsd:attribute ref="orientation" default="0.0" />
        <xsd:attribute ref="penwidth" />
        <xsd:attribute ref="peripheries" />
        <xsd:attribute ref="pin" default="false" />
        <xsd:attribute ref="pos" />
        <xsd:attribute ref="rects" />
        <xsd:attribute ref="regular" default="false" />
        <xsd:attribute ref="root" default="false" />
        <xsd:attribute ref="samplepoints" default="false" />
        <xsd:attribute ref="shape" default="ellipse" />
        <xsd:attribute ref="shapefile" />
        <xsd:attribute ref="showboxes" default="0" />
        <xsd:attribute ref="sides" default="4" />
        <xsd:attribute ref="skew" default="0.0" />
        <xsd:attribute ref="sortv" default="0" />
        <xsd:attribute ref="style" />
        <xsd:attribute ref="target" />
        <xsd:attribute ref="tooltip" />
        <xsd:attribute ref="URL" />
        <xsd:attribute ref="vertices" />
        <xsd:attribute ref="width" default="0.75" />
        <xsd:attribute ref="xlabel" />
        <xsd:attribute ref="xlp" default="0.0" />
        <xsd:attribute ref="z" default="0.0" />
    </xsd:complexType>

    <xsd:complexType name="graph">
        <xsd:attribute ref="bb" />
        <xsd:attribute ref="beautify" default="false" />
        <xsd:attribute ref="bgcolor" />
        <xsd:attribute ref="center" />
        <xsd:attribute ref="charset" />
        <xsd:attribute ref="class" />
        <xsd:attribute ref="clusterrank" default="local" />
        <xsd:attribute ref="colorscheme" />
        <xsd:attribute ref="comment" />
        <xsd:attribute ref="compound" default="false" />
        <xsd:attribute ref="concentrate" default="false" />
        <xsd:attribute ref="Damping" default="0.99" />
        <xsd:attribute ref="defaultdist" />
        <xsd:attribute ref="dim" default="2" />
        <xsd:attribute ref="dimen" default="2" />
        <xsd:attribute ref="diredgeconstraints" default="false" />
        <xsd:attribute ref="dpi" default="96.0" />
        <xsd:attribute ref="epsilon" />
        <xsd:attribute ref="esep" />
        <xsd:attribute ref="fontcolor" default="black" />
        <xsd:attribute ref="fontname" default="Times-Roman" />
        <xsd:attribute ref="fontnames" />
        <xsd:attribute ref="fontpath" />
        <xsd:attribute ref="fontsize" default="14.0" />
        <xsd:attribute ref="forcelabels" default="true" />
        <xsd:attribute ref="gradientangle" default="0" />
        <xsd:attribute ref="href" />
        <xsd:attribute ref="id" />
        <xsd:attribute ref="imagepath" />
        <xsd:attribute ref="inputscale" />
        <xsd:attribute ref="K" default="0.3" />
        <xsd:attribute ref="label" />
        <xsd:attribute ref="label_scheme" default="0" />
        <xsd:attribute ref="labeljust" default="c" />
        <xsd:attribute ref="labelloc" default="b" />
        <xsd:attribute ref="landscape" default="false" />
        <xsd:attribute ref="layerlistsep" default="," />
        <xsd:attribute ref="layers" />
        <xsd:attribute ref="layerselect" />
        <xsd:attribute ref="layersep" default=" :	" />
        <xsd:attribute ref="layout" />
        <xsd:attribute ref="levels" />
        <xsd:attribute ref="levelsgap" default="0.0" />
        <xsd:attribute ref="lheight" />
        <xsd:attribute ref="linelength" efault="128" />
        <xsd:attribute ref="lp" />
        <xsd:attribute ref="lwidth" />
        <xsd:attribute ref="margin" />
        <xsd:attribute ref="maxiter" />
        <xsd:attribute ref="mclimit" default="1.0" />
        <xsd:attribute ref="mindist" default="1.0" />
        <xsd:attribute ref="mode" default="major" />
        <xsd:attribute ref="model" default="shortpath" />
        <xsd:attribute ref="newrank" default="false" />
        <xsd:attribute ref="nodesep" default="0.25" />
        <xsd:attribute ref="nojustify" default="false" />
        <xsd:attribute ref="normalize" default="false" />
        <xsd:attribute ref="notranslate" default="false" />
        <xsd:attribute ref="nslimit" />
        <xsd:attribute ref="nslimit1" />
        <xsd:attribute ref="oneblock" default="false" />
        <xsd:attribute ref="ordering" />
        <xsd:attribute ref="outputorder" default="breadthfirst" />
        <xsd:attribute ref="overlap" default="true" />
        <xsd:attribute ref="overlap_scaling" default="-4" />
        <xsd:attribute ref="overlap_shrink" default="true" />
        <xsd:attribute ref="pack" default="false" />
        <xsd:attribute ref="packmode" default="node" />
        <xsd:attribute ref="pad" />
        <xsd:attribute ref="page" />
        <xsd:attribute ref="pagedir" />
        <xsd:attribute ref="quadtree" default="normal" />
        <xsd:attribute ref="quantum" default="0.0" />
        <xsd:attribute ref="rankdir" default="TB" />
        <xsd:attribute ref="ranksep" />
        <xsd:attribute ref="ratio" />
        <xsd:attribute ref="remincross" default="false" />
        <xsd:attribute ref="repulsiveforce" default="1.0" />
        <xsd:attribute ref="resolution" default="96.0" />
        <xsd:attribute ref="root" />
        <xsd:attribute ref="rotate" default="0" />
        <xsd:attribute ref="rotation" default="0" />
        <xsd:attribute ref="scale" />
        <xsd:attribute ref="searchsize" default="30" />
        <xsd:attribute ref="sep" default="0.1" />
        <xsd:attribute ref="showboxes" default="0" />
        <xsd:attribute ref="size" />
        <xsd:attribute ref="smoothing" default="none" />
        <xsd:attribute ref="sortv" default="0" />
        <xsd:attribute ref="splines" />
        <xsd:attribute ref="start" />
        <xsd:attribute ref="stylesheet" />
        <xsd:attribute ref="target" />
        <xsd:attribute ref="TBbalance" />
        <xsd:attribute ref="tooltip" />
        <xsd:attribute ref="truecolor" />
        <xsd:attribute ref="URL" />
        <xsd:attribute ref="viewport" />
        <xsd:attribute ref="voro_margin" default="0.05" />
        <xsd:attribute ref="xdotversion" />
    </xsd:complexType>

    <xsd:complexType name="subgraph">
        <xsd:attribute ref="rank" />
    </xsd:complexType>

    <xsd:complexType name="cluster">
        <xsd:attribute ref="area" />
        <xsd:attribute ref="bgcolor" />
        <xsd:attribute ref="class" />
        <xsd:attribute ref="cluster" />
        <xsd:attribute ref="color" default="black" />
        <xsd:attribute ref="colorscheme" />
        <xsd:attribute ref="fillcolor" default="black" />
        <xsd:attribute ref="fontcolor" default="black" />
        <xsd:attribute ref="fontname" default="Times-Roman" />
        <xsd:attribute ref="fontsize" default="14.0" />
        <xsd:attribute ref="href" />
        <xsd:attribute ref="id" />
        <xsd:attribute ref="K" />
        <xsd:attribute ref="label" />
        <xsd:attribute ref="labeljust" default="c" />
        <xsd:attribute ref="labelloc" default="t" />
        <xsd:attribute ref="layer" />
        <xsd:attribute ref="lheight" />
        <xsd:attribute ref="lp" />
        <xsd:attribute ref="lwidth" />
        <xsd:attribute ref="nojustify" default="false" />
        <xsd:attribute ref="pencolor" />
        <xsd:attribute ref="penwidth" />
        <xsd:attribute ref="peripheries" />
        <xsd:attribute ref="sortv" default="0" />
        <xsd:attribute ref="style" />
        <xsd:attribute ref="target" />
        <xsd:attribute ref="tooltip" />
        <xsd:attribute ref="URL" />
    </xsd:complexType>

</xsd:schema>
